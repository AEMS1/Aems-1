<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cryptomaster</title>

<!-- Modern font -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>

<style>
  /* Reset and base styles */
  * {
    box-sizing: border-box;
  }
  body, html {
    margin: 0; padding: 0;
    height: 100%;
    font-family: 'Inter', sans-serif;
    background: #121d40;
    color: #eee;
    overflow-x: hidden;
  }

  /* Particle canvas full screen */
  #particle-canvas {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 0;
    pointer-events: none;
  }

  /* Main container with grid layout */
  .container {
    position: relative;
    z-index: 10;
    max-width: 1000px;
    margin: 40px auto;
    background: rgba(22, 34, 62, 0.9);
    border-radius: 20px;
    box-shadow: 0 0 40px #5a95ffaa;
    display: grid;
    grid-template-columns: 2.2fr 1fr;
    gap: 32px;
    padding: 30px 35px;
    min-height: 600px;
  }

  /* Responsive for smaller screens */
  @media (max-width: 720px) {
    .container {
      grid-template-columns: 1fr;
      margin: 20px;
      padding: 20px 15px;
      min-height: auto;
    }
  }

  /* Chart panel styling */
  .chart-panel {
    background: #1e2a5a;
    border-radius: 18px;
    padding: 25px 30px;
    box-shadow: inset 0 0 25px #5a95ff55;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  .chart-panel h2 {
    font-weight: 700;
    font-size: 1.5rem;
    margin-bottom: 22px;
    color: #7cc1ff;
    text-shadow: 0 0 8px #7cc1ffcc;
  }
  #lineChart {
    width: 100% !important;
    max-height: 360px;
  }

  /* Swap panel styling */
  .swap-panel {
    background: #1e2a4a;
    border-radius: 18px;
    padding: 30px 25px;
    box-shadow: inset 0 0 25px #ff5a5a55;
    display: flex;
    flex-direction: column;
    color: #ddd;
  }
  .swap-panel h2 {
    font-weight: 700;
    font-size: 1.4rem;
    margin-bottom: 20px;
    color: #ff5a5a;
    text-align: center;
    text-shadow: 0 0 8px #ff5a5aaa;
  }
  #walletInfo {
    font-weight: 600;
    font-size: 0.95rem;
    color: #f2b636;
    text-align: center;
    margin-bottom: 14px;
    min-height: 1.5em;
    word-break: break-word;
  }
  button, select, input {
    font-family: 'Inter', sans-serif;
    border-radius: 12px;
    border: none;
    padding: 12px 16px;
    margin-bottom: 18px;
    font-size: 1rem;
    outline: none;
    transition: all 0.3s ease;
    cursor: pointer;
    color: #222;
  }
  select {
    background: #7cc1ff;
    font-weight: 700;
    color: #000;
    cursor: pointer;
    box-shadow: 0 0 18px #7cc1ff88;
    appearance: none;
    -webkit-appearance: none;
    background-image: url('data:image/svg+xml;utf8,<svg fill="%23000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/></svg>');
    background-repeat: no-repeat;
    background-position: 95% center;
    background-size: 18px;
  }
  input[type=number] {
    background: #ff5a5a;
    color: #fff;
    font-weight: 600;
    text-align: center;
    box-shadow: 0 0 18px #ff5a5a88;
  }
  button#connectWallet {
    background: linear-gradient(90deg, #7cc1ff, #2b67ff);
    color: white;
    font-weight: 700;
    box-shadow: 0 0 25px #7cc1ffaa;
  }
  button#connectWallet:hover {
    background: linear-gradient(90deg, #2b67ff, #7cc1ff);
    box-shadow: 0 0 35px #7cc1ffcc;
    transform: scale(1.07);
  }
  button#swap {
    background: linear-gradient(90deg, #ff5a5a, #ff3636);
    color: white;
    font-weight: 700;
    box-shadow: 0 0 25px #ff5a5aaa;
  }
  button#swap:hover:not(:disabled) {
    background: linear-gradient(90deg, #ff3636, #ff5a5a);
    box-shadow: 0 0 35px #b82c2ccc;
    transform: scale(1.07);
  }
  button#swap:disabled {
    background: rgba(255, 90, 90, 0.45);
    cursor: not-allowed;
    box-shadow: none;
    transform: none;
  }
  #priceFeed {
    text-align: center;
    font-weight: 600;
    color: #f2b636;
    font-size: 1.1rem;
    margin-bottom: 14px;
    min-height: 1.3em;
  }
  #balances {
    color: #61ffa2;
    font-weight: 600;
    font-size: 0.9rem;
    margin-bottom: 18px;
    text-align: center;
    min-height: 1.5em;
  }
  #liquidityLink {
    margin-top: auto;
    text-align: center;
  }
  #liquidityLink a {
    color: #7cc1ff;
    font-weight: 600;
    text-decoration: none;
  }
  #liquidityLink a:hover {
    text-decoration: underline;
  }

  /* Modal for adding custom token */
  #customTokenModal {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%) scale(0.85);
    background: linear-gradient(135deg, #7cc1ffdd, #2b67ffdd);
    border-radius: 22px;
    box-shadow: 0 0 45px #2b67ffcc;
    width: 340px;
    max-width: 90vw;
    padding: 30px 35px;
    z-index: 1000;
    opacity: 0;
    pointer-events: none;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    text-align: center;
    color: #000;
  }
  #customTokenModal.active {
    opacity: 1;
    pointer-events: auto;
    transform: translate(-50%, -50%) scale(1);
  }
  #customTokenModal h3 {
    margin-bottom: 25px;
    font-weight: 700;
    font-size: 1.3rem;
  }
  #customTokenModal input[type=text] {
    width: 100%;
    padding: 12px 18px;
    font-size: 1rem;
    border-radius: 14px;
    border: none;
    outline: none;
    margin-bottom: 22px;
    box-shadow: inset 0 0 18px #2b67ffaa;
  }
  #customTokenModal button {
    background: #ff5a5a;
    color: white;
    font-weight: 700;
    padding: 14px 0;
    border-radius: 14px;
    width: 100%;
    box-shadow: 0 0 25px #ff5a5aaa;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }
  #customTokenModal button:hover {
    background: #ff3636;
  }
  #customTokenModal button.cancel-btn {
    background: #2b67ff;
    margin-top: 12px;
    box-shadow: 0 0 25px #2b67ffcc;
  }
  #customTokenModal button.cancel-btn:hover {
    background: #1448c9;
  }
</style>
</head>
<body>

<canvas id="particle-canvas"></canvas>

<div class="container">
  <!-- Chart Panel -->
  <section class="chart-panel">
    <h2>Price Chart (Last 24h)</h2>
    <canvas id="lineChart" aria-label="Price chart" role="img"></canvas>
  </section>

  <!-- Swap Panel -->
  <section class="swap-panel" aria-label="Swap Panel">
    <h2>Cryptomaster</h2>

    <div id="walletInfo" aria-live="polite">Not connected friend</div>
    <button id="connectWallet" aria-label="Connect Wallet Button">Connect Wallet</button>

    <label for="tokenFrom">From:</label>
    <select id="tokenFrom" aria-describedby="balanceFromDesc">
      <option value="busd">BUSD</option>
      <option value="usdt">USDT</option>
      <option value="bnb">BNB</option>
      <option value="custom">Add Custom Token</option>
    </select>
    <div id="balanceFromDesc" style="font-size: 0.85rem; color: #a0c9ff; margin-bottom: 12px;">Balance: <span id="balanceFrom">0</span></div>

    <label for="tokenTo">To:</label>
    <select id="tokenTo" aria-describedby="balanceToDesc">
      <option value="usdt">USDT</option>
      <option value="busd">BUSD</option>
      <option value="bnb">BNB</option>
      <option value="ADA">ADA</option>
      <option value="custom">Add Custom Token</option>
    </select>
    <div id="balanceToDesc" style="font-size: 0.85rem; color: #a0c9ff; margin-bottom: 12px;">Balance: <span id="balanceTo">0</span></div>

    <label for="amountFrom">Amount:</label>
    <input id="amountFrom" type="number" min="0" step="any" placeholder="Enter amount" aria-describedby="balanceFromDesc" />

    <div id="priceFeed" aria-live="polite"></div>

    <button id="swap" disabled aria-label="Swap Tokens Button">Swap</button>

    <div id="balances"></div>

    <div id="liquidityLink">
      <a href="add-liquidity.html">
        ➕ Add liquidity & list your token
      </a>
    </div>
    

<!-- Modal for adding custom token -->
<div id="customTokenModal" role="dialog" aria-modal="true" aria-labelledby="modalTitle" aria-describedby="modalDesc">
  <h3 id="modalTitle">Add Custom Token</h3>
  <input type="text" id="customTokenAddress" placeholder="Enter token contract address" aria-describedby="modalDesc" />
  <button id="addCustomTokenBtn">Add Token</button>
  <button class="cancel-btn" id="cancelCustomTokenBtn">Cancel</button>
</div>

<script>
  // Particle effect
  const canvas = document.getElementById('particle-canvas');
  const ctx = canvas.getContext('2d');
  let particlesArray = [];
  let width, height;

  function initCanvas() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
  }
  initCanvas();

  class Particle {
    constructor() {
      this.x = Math.random() * width;
      this.y = Math.random() * height;
      this.size = Math.random() * 3 + 1;
      this.speedX = (Math.random() - 0.5) * 1;
      this.speedY = (Math.random() - 0.5) * 1;
      this.color = 'rgba(124, 193, 255, 0.8)';
    }
    update() {
      this.x += this.speedX;
      this.y += this.speedY;
      if(this.x < 0 || this.x > width) this.speedX *= -1;
      if(this.y < 0 || this.y > height) this.speedY *= -1;
    }
    draw() {
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.shadowColor = '#7cc1ff';
      ctx.shadowBlur = 10;
      ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function createParticles(num=80) {
    particlesArray = [];
    for(let i=0; i<num; i++) {
      particlesArray.push(new Particle());
    }
  }

  function animateParticles() {
    ctx.clearRect(0,0,width,height);
    particlesArray.forEach(p => {
      p.update();
      p.draw();
    });
    requestAnimationFrame(animateParticles);
  }

  createParticles();
  animateParticles();

  window.addEventListener('resize', () => {
    initCanvas();
    createParticles();
  });

  // Chart.js setup
  const ctxChart = document.getElementById('lineChart').getContext('2d');
  let lineChart = null;

  // Dummy price data for 24h (can replace with real API)
  let prices = [];
  let labels = [];
  function generateDummyData() {
    prices = [];
    labels = [];
    let basePrice = 1;
    for(let i=0; i<24; i++) {
      basePrice += (Math.random() - 0.5) * 0.02;
      prices.push(parseFloat(basePrice.toFixed(4)));
      labels.push(i + ":00");
    }
  }

  function drawChart() {
    if(lineChart) lineChart.destroy();
    lineChart = new Chart(ctxChart, {
      type: 'line',
      data: {
        labels,
        datasets: [{
          label: 'Token Price',
          data: prices,
          borderColor: '#7cc1ff',
          backgroundColor: 'rgba(124, 193, 255, 0.3)',
          fill: true,
          tension: 0.3,
          pointRadius: 3,
          pointHoverRadius: 6,
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: {
            beginAtZero: false,
            ticks: {
              color: '#a0c9ff'
            },
            grid: {
              color: '#2b67ff55'
            }
          },
          x: {
            ticks: {
              color: '#a0c9ff'
            },
            grid: {
              color: '#2b67ff33'
            }
          }
        },
        plugins: {
          legend: {
            labels: {
              color: '#7cc1ff',
              font: { weight: 'bold' }
            }
          },
          tooltip: {
            enabled: true,
            backgroundColor: '#2b67ffdd',
            titleColor: '#fff',
            bodyColor: '#ddd',
          }
        }
      }
    });
  }

  generateDummyData();
  drawChart();

  // Web3 & Swap logic

  let web3;
  let userAccount = null;

  // Token list and their dummy prices (in USD)
  const tokenList = {
    busd: { symbol: 'BUSD', address: '0xe9e7cea3dedca5984780bafc599bd69add087d56', decimals: 18, priceUSD: 1.00 },
    ada: { symbol: 'ADA', address: '0x55d398326f99059ff775485246999027b3197955', decimals: 18, priceUSD: 3.00 },
    usdt: { symbol: 'USDT', address: '0x55d398326f99059ff775485246999027b3197955', decimals: 18, priceUSD: 1.00 },
    bnb: { symbol: 'BNB', address: 'native', decimals: 18, priceUSD: 350.00 },
  };

  // Custom tokens storage (address => token info)
  let customTokens = {};

  // Elements
  const connectWalletBtn = document.getElementById('connectWallet');
  const walletInfo = document.getElementById('walletInfo');
  const tokenFromSelect = document.getElementById('tokenFrom');
  const tokenToSelect = document.getElementById('tokenTo');
  const amountFromInput = document.getElementById('amountFrom');
  const swapBtn = document.getElementById('swap');
  const priceFeedDiv = document.getElementById('priceFeed');
  const balanceFromSpan = document.getElementById('balanceFrom');
  const balanceToSpan = document.getElementById('balanceTo');

  const customTokenModal = document.getElementById('customTokenModal');
  const customTokenAddressInput = document.getElementById('customTokenAddress');
  const addCustomTokenBtn = document.getElementById('addCustomTokenBtn');
  const cancelCustomTokenBtn = document.getElementById('cancelCustomTokenBtn');

  // Helper to check if string is a valid Ethereum/BSC address
  function isValidAddress(addr) {
    return /^0x[a-fA-F0-9]{40}$/.test(addr);
  }

  // Open/close modal functions
  function openCustomTokenModal() {
    customTokenAddressInput.value = '';
    customTokenModal.classList.add('active');
    customTokenAddressInput.focus();
  }
  function closeCustomTokenModal() {
    customTokenModal.classList.remove('active');
  }

  // Load custom tokens from localStorage
  function loadCustomTokens() {
    const stored = localStorage.getItem('customTokens');
    if(stored) {
      try {
        customTokens = JSON.parse(stored);
      } catch(e) {
        customTokens = {};
      }
    }
  }
  // Save custom tokens to localStorage
  function saveCustomTokens() {
    localStorage.setItem('customTokens', JSON.stringify(customTokens));
  }

  // Update token selects with custom tokens included
  function updateTokenSelects() {
    // Clear custom tokens from selects first (except "Add Custom Token" option)
    [...tokenFromSelect.options].forEach(opt => {
      if(opt.value !== 'busd' && opt.value !== 'usdt' && opt.value !== 'bnb' && opt.value !== 'custom') {
        tokenFromSelect.removeChild(opt);
      }
    });
    [...tokenToSelect.options].forEach(opt => {
      if(opt.value !== 'busd' && opt.value !== 'usdt' && opt.value !== 'bnb') {
        tokenToSelect.removeChild(opt);
      }
    });

    // Add custom tokens
    for(const addr in customTokens) {
      const token = customTokens[addr];
      // From select
      const optionFrom = document.createElement('option');
      optionFrom.value = addr;
      optionFrom.textContent = token.symbol + ' (Custom)';
      tokenFromSelect.appendChild(optionFrom);
      // To select - insert before last option "custom"
      const optionTo = document.createElement('option');
      optionTo.value = addr;
      optionTo.textContent = token.symbol + ' (Custom)';
      tokenToSelect.insertBefore(optionTo, tokenToSelect.querySelector('option[value="custom"]'));
    }
  }

  // On page load, load custom tokens
  loadCustomTokens();
  updateTokenSelects();

  // Connect wallet
  async function connectWallet() {
    if(window.ethereum) {
      try {
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        web3 = new Web3(window.ethereum);
        const accounts = await web3.eth.getAccounts();
        if(accounts.length > 0) {
          userAccount = accounts[0];
          walletInfo.textContent = 'Connected: ' + userAccount.slice(0,6) + '...' + userAccount.slice(-4);
          connectWalletBtn.style.display = 'none';
          updateBalances();
          validateSwap();
          // Listen for account changes
          window.ethereum.on('accountsChanged', (accounts) => {
            if(accounts.length === 0) {
              userAccount = null;
              walletInfo.textContent = 'Not connected';
              connectWalletBtn.style.display = 'inline-block';
              balanceFromSpan.textContent = '0';
              balanceToSpan.textContent = '0';
              swapBtn.disabled = true;
            } else {
              userAccount = accounts[0];
              walletInfo.textContent = 'Connected: ' + userAccount.slice(0,6) + '...' + userAccount.slice(-4);
              updateBalances();
              validateSwap();
            }
          });
        }
      } catch(err) {
        alert('Wallet connection rejected or failed.');
      }
    } else {
      alert('MetaMask or compatible wallet not detected.');
    }
  }

  // Get ERC20 balance
  async function getERC20Balance(tokenAddress, account) {
    const minABI = [
      {constant:true,inputs:[{name:"_owner",type:"address"}],name:"balanceOf",outputs:[{name:"balance",type:"uint256"}],type:"function"},
      {constant:true,inputs:[],name:"decimals",outputs:[{name:"",type:"uint8"}],type:"function"},
      {constant:true,inputs:[],name:"symbol",outputs:[{name:"",type:"string"}],type:"function"},
    ];
    try {
      const tokenContract = new web3.eth.Contract(minABI, tokenAddress);
      let balance = await tokenContract.methods.balanceOf(account).call();
      let decimals = await tokenContract.methods.decimals().call();
      let symbol = await tokenContract.methods.symbol().call();
      return {balance, decimals: Number(decimals), symbol};
    } catch(e) {
      return null;
    }
  }

  // Update balances display
  async function updateBalances() {
    if(!userAccount) {
      balanceFromSpan.textContent = '0';
      balanceToSpan.textContent = '0';
      return;
    }
    let fromValue = tokenFromSelect.value;
    let toValue = tokenToSelect.value;

    let balanceFromVal = 0;
    let balanceToVal = 0;

    if(fromValue === 'bnb') {
      try {
        const bal = await web3.eth.getBalance(userAccount);
        balanceFromVal = Number(web3.utils.fromWei(bal, 'ether'));
      } catch(e) {
        balanceFromVal = 0;
      }
    } else {
      let token = tokenList[fromValue] || customTokens[fromValue];
      if(token && token.address && token.address !== 'native') {
        let res = await getERC20Balance(token.address, userAccount);
        if(res) balanceFromVal = Number(web3.utils.fromWei(res.balance, 'ether'));
      } else {
        balanceFromVal = 0;
      }
    }

    if(toValue === 'bnb') {
      try {
        const bal = await web3.eth.getBalance(userAccount);
        balanceToVal = Number(web3.utils.fromWei(bal, 'ether'));
      } catch(e) {
        balanceToVal = 0;
      }
    } else {
      let token = tokenList[toValue] || customTokens[toValue];
      if(token && token.address && token.address !== 'native') {
        let res = await getERC20Balance(token.address, userAccount);
        if(res) balanceToVal = Number(web3.utils.fromWei(res.balance, 'ether'));
      } else {
        balanceToVal = 0;
      }
    }

    balanceFromSpan.textContent = balanceFromVal.toFixed(4);
    balanceToSpan.textContent = balanceToVal.toFixed(4);
  }

  // Update price feed display (dummy prices)
  function updatePriceFeed() {
    let fromVal = tokenFromSelect.value;
    let toVal = tokenToSelect.value;

    let fromToken = tokenList[fromVal] || customTokens[fromVal];
    let toToken = tokenList[toVal] || customTokens[toVal];

    if(!fromToken || !toToken) {
      priceFeedDiv.textContent = '';
      return;
    }

    // Price calculation: price of from token in USD / price of to token in USD
    let price = fromToken.priceUSD / toToken.priceUSD;
    priceFeedDiv.textContent = `1 ${fromToken.symbol} ≈ ${price.toFixed(6)} ${toToken.symbol}`;
  }

  // Validate swap input and enable/disable swap button
  function validateSwap() {
    let amount = parseFloat(amountFromInput.value);
    if(!userAccount || !amount || amount <= 0) {
      swapBtn.disabled = true;
      return;
    }

    let fromBalance = parseFloat(balanceFromSpan.textContent);
    if(isNaN(fromBalance)) fromBalance = 0;

    if(amount > fromBalance) {
      swapBtn.disabled = true;
      return;
    }

    // Prevent swapping same token
    if(tokenFromSelect.value === tokenToSelect.value) {
      swapBtn.disabled = true;
      return;
    }

    swapBtn.disabled = false;
  }

  // Swap button click handler (dummy)
  async function doSwap() {
    alert('Swap functionality is not implemented in this demo.');
  }

  // Event listeners
  connectWalletBtn.addEventListener('click', connectWallet);

  tokenFromSelect.addEventListener('change', () => {
    if(tokenFromSelect.value === 'custom') {
      // Open modal to add custom token
      tokenFromSelect.value = ''; // reset select so user chooses manually after adding
      openCustomTokenModal();
    } else {
      updatePriceFeed();
      updateBalances();
      validateSwap();
    }
  });

  tokenToSelect.addEventListener('change', () => {
    updatePriceFeed();
    updateBalances();
    validateSwap();
  });

  amountFromInput.addEventListener('input', validateSwap);
  swapBtn.addEventListener('click', doSwap);

  addCustomTokenBtn.addEventListener('click', async () => {
    const address = customTokenAddressInput.value.trim();
    if(!isValidAddress(address)) {
      alert('Please enter a valid Ethereum or BSC token contract address.');
      return;
    }

    // Check if token already added
    if(tokenFromSelect.querySelector(`option[value="${address}"]`) || tokenToSelect.querySelector(`option[value="${address}"]`)) {
      alert('This token is already added.');
      return;
    }

    // Fetch token info via web3 if connected, else dummy
    let symbol = 'CTK';
    let decimals = 18;
    if(web3) {
      try {
        const minABI = [
          {constant:true,inputs:[],name:"symbol",outputs:[{name:"",type:"string"}],type:"function"},
          {constant:true,inputs:[],name:"decimals",outputs:[{name:"",type:"uint8"}],type:"function"},
        ];
        const tokenContract = new web3.eth.Contract(minABI, address);
        symbol = await tokenContract.methods.symbol().call();
        decimals = await tokenContract.methods.decimals().call();
      } catch(e) {
        alert('Failed to fetch token info, adding with default symbol "CTK" and 18 decimals.');
      }
    }

    // Add custom token to list
    customTokens[address] = {
      symbol,
      address,
      decimals: Number(decimals),
      priceUSD: 0.01 // Dummy price
    };

    saveCustomTokens();
    updateTokenSelects();
    closeCustomTokenModal();
    alert(`Custom token ${symbol} added.`);
  });

  cancelCustomTokenBtn.addEventListener('click', closeCustomTokenModal);

  // Initialize price feed and balances on page load
  updatePriceFeed();
  updateBalances();

</script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/web3@1.8.2/dist/web3.min.js"></script>
</body>
</html>

<script src=""></script>
<script>
  const feeWallet = "0xA328597cC78C4aB9f8CEd8eB1096Ef614B8b3a98";
