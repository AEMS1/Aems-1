<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AMS Snake Arena (Testnet)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.ethers.io/lib/ethers-5.6.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
  <style>
    body { font-family: sans-serif; text-align: center; margin: 20px; }
    button { padding: 10px 20px; margin: 5px; }
    #game-container { margin-top: 20px; display: flex; justify-content: center; }
    canvas { border: 2px solid #333; }
  </style>
</head>
<body>
  <h1>üêç AMS Snake Arena (Testnet)</h1>  <div>
    <button onclick="connectWallet()">Connect Wallet</button>
    <p>Address: <span id="address">-</span></p>
    <p>AMS Balance: <span id="balance">-</span></p>
  </div>  <h3>Choose Arena</h3>
  <div>
    <button onclick="enterArena(0)">Arena 1 - 100 AMS</button>
    <button onclick="enterArena(1)">Arena 2 - 200 AMS</button>
    <button onclick="enterArena(2)">Arena 3 - 400 AMS</button>
    <button onclick="enterArena(3)">Arena 4 - 1000 AMS</button>
  </div>  <div id="status"></div>  <div id="game-container"></div><script>
const tokenAddress = "0xABCDabcd1234EFef5678abcd9012efEFabcdEf12";
const gameAddress = "0x1234abcd5678EFef9012abcd3456EfefabcdABCD";
const tokenAbi = [
  "function balanceOf(address) view returns (uint256)",
  "function transferFrom(address from, address to, uint amount) returns (bool)",
  "function approve(address spender, uint256 amount) returns (bool)"
];
const gameAbi = [
  "function enterArena(uint8 arenaType) external",
  "function submitScore(uint gameId, uint256 score) external",
  "function getGameCount() public view returns (uint)",
  "function getPlayers(uint gameId) public view returns (address[] memory)"
];

let provider, signer, userAddress, tokenContract, gameContract;

async function connectWallet() {
  provider = new ethers.providers.Web3Provider(window.ethereum);
  await provider.send("eth_requestAccounts", []);
  signer = provider.getSigner();
  userAddress = await signer.getAddress();
  document.getElementById("address").innerText = userAddress;

  tokenContract = new ethers.Contract(tokenAddress, tokenAbi, signer);
  gameContract = new ethers.Contract(gameAddress, gameAbi, signer);
  loadBalance();
}

async function loadBalance() {
  const bal = await tokenContract.balanceOf(userAddress);
  document.getElementById("balance").innerText = ethers.utils.formatUnits(bal, 18) + " AMS";
}

async function enterArena(type) {
  const fees = ["100", "200", "400", "1000"];
  const amt = ethers.utils.parseUnits(fees[type], 18);
  await tokenContract.approve(gameAddress, amt);
  const tx = await gameContract.enterArena(type);
  document.getElementById("status").innerText = `Entered Arena ${type + 1} - Tx sent...`;
  await tx.wait();
  document.getElementById("status").innerText = `Entered Arena ${type + 1} successfully.`;
  loadBalance();
}

async function submitBlockchainScore(score) {
  const gameCount = await gameContract.getGameCount();
  const gameId = gameCount.toNumber() - 1;
  const tx = await gameContract.submitScore(gameId, score);
  await tx.wait();
  alert(`Score ${score} submitted for game #${gameId}`);
}

// Phaser Game Config
let score = 0;
const config = {
  type: Phaser.AUTO,
  width: 320,
  height: 320,
  backgroundColor: '#000000',
  parent: 'game-container',
  physics: { default: 'arcade' },
  scene: {
    preload: preload,
    create: create,
    update: update
  }
};

let snake, food, cursors, direction = 'RIGHT', lastMoveTime = 0;
let moveInterval = 150;
let snakeBody = [];

const game = new Phaser.Game(config);

function preload() {
  this.load.image('food', 'https://labs.phaser.io/assets/sprites/apple.png');
}

function create() {
  snake = this.add.rectangle(160, 160, 16, 16, 0x00ff00);
  this.physics.add.existing(snake);
  cursors = this.input.keyboard.createCursorKeys();
  food = this.physics.add.image(Phaser.Math.Between(0, 19) * 16, Phaser.Math.Between(0, 19) * 16, 'food').setScale(0.5);
  snakeBody = [{ x: 160, y: 160 }];
}

function update(time) {
  if (time - lastMoveTime > moveInterval) {
    lastMoveTime = time;
    let head = Object.assign({}, snakeBody[0]);
    if (cursors.left.isDown && direction !== 'RIGHT') direction = 'LEFT';
    else if (cursors.right.isDown && direction !== 'LEFT') direction = 'RIGHT';
    else if (cursors.up.isDown && direction !== 'DOWN') direction = 'UP';
    else if (cursors.down.isDown && direction !== 'UP') direction = 'DOWN';

    if (direction === 'LEFT') head.x -= 16;
    else if (direction === 'RIGHT') head.x += 16;
    else if (direction === 'UP') head.y -= 16;
    else if (direction === 'DOWN') head.y += 16;

    // Check boundaries
    if (head.x < 0 || head.x >= 320 || head.y < 0 || head.y >= 320 || snakeBody.slice(1).some(p => p.x === head.x && p.y === head.y)) {
      alert(`Game Over! Your Score: ${score}`);
      submitBlockchainScore(score);
      score = 0;
      snakeBody = [{ x: 160, y: 160 }];
      direction = 'RIGHT';
      return;
    }

    snakeBody.unshift(head);
    if (head.x === food.x && head.y === food.y) {
      score++;
      food.setPosition(Phaser.Math.Between(0, 19) * 16, Phaser.Math.Between(0, 19) * 16);
    } else {
      snakeBody.pop();
    }

    snake.setPosition(head.x, head.y);
  }
}
</script></body>
</html>
